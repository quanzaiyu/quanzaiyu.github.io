(window.webpackJsonp=window.webpackJsonp||[]).push([[527],{925:function(t,e,a){"use strict";a.r(e);var s=a(1),n=Object(s.a)({},function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"kubernetes-架构及原理分析"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#kubernetes-架构及原理分析","aria-hidden":"true"}},[t._v("#")]),t._v(" Kubernetes 架构及原理分析")]),t._v(" "),a("h2",{attrs:{id:"资源对象与基本概念解析"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#资源对象与基本概念解析","aria-hidden":"true"}},[t._v("#")]),t._v(" 资源对象与基本概念解析")]),t._v(" "),a("p",[t._v("以下列举的内容都是 kubernetes 中的 Object，这些对象都可以在 yaml 文件中作为一种 API 类型来配置。")]),t._v(" "),a("ul",[a("li",[t._v("Pod")]),t._v(" "),a("li",[t._v("Node")]),t._v(" "),a("li",[t._v("Namespace")]),t._v(" "),a("li",[t._v("Service")]),t._v(" "),a("li",[t._v("Volume")]),t._v(" "),a("li",[t._v("PersistentVolume")]),t._v(" "),a("li",[t._v("Deployment")]),t._v(" "),a("li",[t._v("Secret")]),t._v(" "),a("li",[t._v("StatefulSet")]),t._v(" "),a("li",[t._v("DaemonSet")]),t._v(" "),a("li",[t._v("ServiceAccount")]),t._v(" "),a("li",[t._v("ReplicationController")]),t._v(" "),a("li",[t._v("ReplicaSet")]),t._v(" "),a("li",[t._v("Job")]),t._v(" "),a("li",[t._v("CronJob")]),t._v(" "),a("li",[t._v("SecurityContext")]),t._v(" "),a("li",[t._v("ResourceQuota")]),t._v(" "),a("li",[t._v("LimitRange")]),t._v(" "),a("li",[t._v("HorizontalPodAutoscaling")]),t._v(" "),a("li",[t._v("Ingress")]),t._v(" "),a("li",[t._v("ConfigMap")]),t._v(" "),a("li",[t._v("Label")]),t._v(" "),a("li",[t._v("CustomResourceDefinition")]),t._v(" "),a("li",[t._v("Role")]),t._v(" "),a("li",[t._v("ClusterRole")])]),t._v(" "),a("p",[t._v("我将它们简单的分类为以下几种资源对象：")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",{staticStyle:{"text-align":"left"}},[t._v("类别")]),t._v(" "),a("th",[t._v("名称")])])]),t._v(" "),a("tbody",[a("tr",[a("td",{staticStyle:{"text-align":"left"}},[t._v("资源对象")]),t._v(" "),a("td",[t._v("Pod、ReplicaSet、ReplicationController、Deployment、StatefulSet、DaemonSet、Job、CronJob、HorizontalPodAutoscaling、Node、Namespace、Service、Ingress、Label、CustomResourceDefinition")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[t._v("存储对象")]),t._v(" "),a("td",[t._v("Volume、PersistentVolume、Secret、ConfigMap")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[t._v("策略对象")]),t._v(" "),a("td",[t._v("SecurityContext、ResourceQuota、LimitRange")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[t._v("身份对象")]),t._v(" "),a("td",[t._v("ServiceAccount、Role、ClusterRole")])])])]),t._v(" "),a("h3",{attrs:{id:"理解-kubernetes-中的对象"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#理解-kubernetes-中的对象","aria-hidden":"true"}},[t._v("#")]),t._v(" 理解 kubernetes 中的对象")]),t._v(" "),a("p",[t._v("在 Kubernetes 系统中，"),a("em",[t._v("Kubernetes 对象")]),t._v(" 是持久化的条目。Kubernetes 使用这些条目去表示整个集群的状态。特别地，它们描述了如下信息：")]),t._v(" "),a("ul",[a("li",[t._v("什么容器化应用在运行（以及在哪个 Node 上）")]),t._v(" "),a("li",[t._v("可以被应用使用的资源")]),t._v(" "),a("li",[t._v("关于应用如何表现的策略，比如重启策略、升级策略，以及容错策略")])]),t._v(" "),a("p",[t._v("Kubernetes 对象是 “目标性记录” —— 一旦创建对象，Kubernetes 系统将持续工作以确保对象存在。通过创建对象，可以有效地告知 Kubernetes 系统，所需要的集群工作负载看起来是什么样子的，这就是 Kubernetes 集群的 "),a("strong",[t._v("期望状态")]),t._v("。")]),t._v(" "),a("p",[t._v("与 Kubernetes 对象工作 —— 是否创建、修改，或者删除 —— 需要使用 "),a("a",{attrs:{href:"https://git.k8s.io/community/contributors/devel/api-conventions.md",target:"_blank",rel:"noopener noreferrer"}},[t._v("Kubernetes API"),a("OutboundLink")],1),t._v("。当使用 "),a("code",[t._v("kubectl")]),t._v(" 命令行接口时，比如，CLI 会使用必要的 Kubernetes API 调用，也可以在程序中直接使用 Kubernetes API。为了实现该目标，Kubernetes 当前提供了一个 "),a("code",[t._v("golang")]),t._v(" "),a("a",{attrs:{href:"https://github.com/kubernetes/client-go",target:"_blank",rel:"noopener noreferrer"}},[t._v("客户端库"),a("OutboundLink")],1),t._v(" ，其它语言库（例如"),a("a",{attrs:{href:"https://github.com/kubernetes-incubator/client-python",target:"_blank",rel:"noopener noreferrer"}},[t._v("Python"),a("OutboundLink")],1),t._v("）也正在开发中。")]),t._v(" "),a("h3",{attrs:{id:"对象-spec-与状态"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#对象-spec-与状态","aria-hidden":"true"}},[t._v("#")]),t._v(" 对象 Spec 与状态")]),t._v(" "),a("p",[t._v("每个 Kubernetes 对象包含两个嵌套的对象字段，它们负责管理对象的配置：对象 "),a("em",[t._v("spec")]),t._v(" 和 对象 "),a("em",[t._v("status")]),t._v("。"),a("em",[t._v("spec")]),t._v(" 必须提供，它描述了对象的 "),a("em",[t._v("期望状态")]),t._v("—— 希望对象所具有的特征。"),a("em",[t._v("status")]),t._v(" 描述了对象的 "),a("em",[t._v("实际状态")]),t._v("，它是由 Kubernetes 系统提供和更新。在任何时刻，Kubernetes 控制平面一直处于活跃状态，管理着对象的实际状态以与我们所期望的状态相匹配。")]),t._v(" "),a("p",[t._v("例如，Kubernetes Deployment 对象能够表示运行在集群中的应用。当创建 Deployment 时，可能需要设置 Deployment 的 spec，以指定该应用需要有 3 个副本在运行。Kubernetes 系统读取 Deployment spec，启动我们所期望的该应用的 3 个实例 —— 更新状态以与 spec 相匹配。如果那些实例中有失败的（一种状态变更），Kubernetes 系统通过修正来响应 spec 和状态之间的不一致 —— 这种情况，启动一个新的实例来替换。")]),t._v(" "),a("p",[t._v("关于对象 spec、status 和 metadata 更多信息，查看 "),a("a",{attrs:{href:"https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",target:"_blank",rel:"noopener noreferrer"}},[t._v("Kubernetes API Conventions"),a("OutboundLink")],1),t._v("。")]),t._v(" "),a("h3",{attrs:{id:"描述-kubernetes-对象"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#描述-kubernetes-对象","aria-hidden":"true"}},[t._v("#")]),t._v(" 描述 Kubernetes 对象")]),t._v(" "),a("p",[t._v("当创建 Kubernetes 对象时，必须提供对象的 spec，用来描述该对象的期望状态，以及关于对象的一些基本信息（例如，名称）。当使用 Kubernetes API 创建对象时（或者直接创建，或者基于"),a("code",[t._v("kubectl")]),t._v("），API 请求必须在请求体中包含 JSON 格式的信息。"),a("strong",[t._v("更常用的是，需要在 .yaml 文件中为 kubectl 提供这些信息")]),t._v("。 "),a("code",[t._v("kubectl")]),t._v(" 在执行 API 请求时，将这些信息转换成 JSON 格式。")]),t._v(" "),a("p",[t._v("这里有一个 "),a("code",[t._v("nginx-deployment.yaml")]),t._v(" 示例文件，展示了 Kubernetes Deployment 的必需字段和对象 spec：")]),t._v(" "),a("div",{staticClass:"language-yaml extra-class"},[a("pre",{pre:!0,attrs:{class:"language-yaml"}},[a("code",[a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("apiVersion")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" v1\n"),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("kind")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" Deployment\n"),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("metadata")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("name")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" nginx"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v("deployment\n"),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("spec")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("replicas")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("template")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("metadata")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n      "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("labels")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("app")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" nginx\n    "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("spec")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n      "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("containers")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n      "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("name")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" nginx\n        "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("image")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" nginx"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("1.7.9\n        "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("ports")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("containerPort")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("80")]),t._v("\n")])])]),a("p",[t._v("一种创建 Deployment 的方式，类似上面使用 "),a("code",[t._v(".yaml")]),t._v(" 文件，是使用 "),a("code",[t._v("kubectl")]),t._v(" 命令行接口（CLI）中的 "),a("code",[t._v("kubectl create")]),t._v(" 命令，传递 "),a("code",[t._v(".yaml")]),t._v(" 作为参数。下面是一个示例：")]),t._v(" "),a("div",{staticClass:"language-bash extra-class"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[t._v("$ kubectl create -f nginx-deployment.yaml --record\ndeployment "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"nginx-deployment"')]),t._v(" created\n")])])]),a("h3",{attrs:{id:"必需字段"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#必需字段","aria-hidden":"true"}},[t._v("#")]),t._v(" 必需字段")]),t._v(" "),a("p",[t._v("在想要创建的 Kubernetes 对象对应的 "),a("code",[t._v(".yaml")]),t._v(" 文件中，需要配置如下的字段：")]),t._v(" "),a("ul",[a("li",[a("code",[t._v("apiVersion")]),t._v(" - 创建该对象所使用的 Kubernetes API 的版本")]),t._v(" "),a("li",[a("code",[t._v("kind")]),t._v(" - 想要创建的对象的类型")]),t._v(" "),a("li",[a("code",[t._v("metadata")]),t._v(" - 帮助识别对象唯一性的数据，包括一个 "),a("code",[t._v("name")]),t._v(" 字符串、UID 和可选的 "),a("code",[t._v("namespace")])])]),t._v(" "),a("p",[t._v("也需要提供对象的 "),a("code",[t._v("spec")]),t._v(" 字段。对象 "),a("code",[t._v("spec")]),t._v(" 的精确格式对每个 Kubernetes 对象来说是不同的，包含了特定于该对象的嵌套字段。"),a("a",{attrs:{href:"https://kubernetes.io/docs/api/",target:"_blank",rel:"noopener noreferrer"}},[t._v("Kubernetes API 参考"),a("OutboundLink")],1),t._v("能够帮助我们找到任何我们想创建的对象的 spec 格式。")]),t._v(" "),a("h2",{attrs:{id:"节点-node"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#节点-node","aria-hidden":"true"}},[t._v("#")]),t._v(" 节点 (Node)")]),t._v(" "),a("p",[t._v("Node是kubernetes集群的工作节点，可以是物理机也可以是虚拟机。")]),t._v(" "),a("p",[t._v("Kubernetes集群中的计算能力由Node提供，最初Node称为服务节点Minion，后来改名为Node。Kubernetes集群中的Node也就等同于Mesos集群中的Slave节点，是所有Pod运行所在的工作主机，可以是物理机也可以是虚拟机。不论是物理机还是虚拟机，工作主机的统一特征是上面要运行kubelet管理节点上运行的容器。")]),t._v(" "),a("h3",{attrs:{id:"node状态"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#node状态","aria-hidden":"true"}},[t._v("#")]),t._v(" Node状态")]),t._v(" "),a("p",[t._v("Node包括如下状态信息：")]),t._v(" "),a("ul",[a("li",[t._v("Address\n"),a("ul",[a("li",[t._v("HostName：可以被kubelet中的"),a("code",[t._v("--hostname-override")]),t._v("参数替代。")]),t._v(" "),a("li",[t._v("ExternalIP：可以被集群外部路由到的IP地址。")]),t._v(" "),a("li",[t._v("InternalIP：集群内部使用的IP，集群外部无法访问。")])])]),t._v(" "),a("li",[t._v("Condition\n"),a("ul",[a("li",[t._v("OutOfDisk：磁盘空间不足时为"),a("code",[t._v("True")])]),t._v(" "),a("li",[t._v("Ready：Node controller 40秒内没有收到node的状态报告为"),a("code",[t._v("Unknown")]),t._v("，健康为"),a("code",[t._v("True")]),t._v("，否则为"),a("code",[t._v("False")]),t._v("。")]),t._v(" "),a("li",[t._v("MemoryPressure：当node有内存压力时为"),a("code",[t._v("True")]),t._v("，否则为"),a("code",[t._v("False")]),t._v("。")]),t._v(" "),a("li",[t._v("DiskPressure：当node有磁盘压力时为"),a("code",[t._v("True")]),t._v("，否则为"),a("code",[t._v("False")]),t._v("。")])])]),t._v(" "),a("li",[t._v("Capacity\n"),a("ul",[a("li",[t._v("CPU")]),t._v(" "),a("li",[t._v("内存")]),t._v(" "),a("li",[t._v("可运行的最大Pod个数")])])]),t._v(" "),a("li",[t._v("Info：节点的一些版本信息，如OS、kubernetes、docker等")])]),t._v(" "),a("h3",{attrs:{id:"node管理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#node管理","aria-hidden":"true"}},[t._v("#")]),t._v(" Node管理")]),t._v(" "),a("p",[t._v("获取所有节点")]),t._v(" "),a("div",{staticClass:"language-bash extra-class"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[t._v("$ kubectl get nodes\n")])])]),a("p",[t._v("禁止pod调度到该节点上")]),t._v(" "),a("div",{staticClass:"language-bash extra-class"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[t._v("$ kubectl cordon "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("node"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n")])])]),a("p",[t._v("驱逐该节点上的所有pod")]),t._v(" "),a("div",{staticClass:"language-bash extra-class"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[t._v("$ kubectl drain "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("node"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n")])])]),a("p",[t._v("该命令会删除该节点上的所有Pod（DaemonSet除外），在其他node上重新启动它们，通常该节点需要维护时使用该命令。直接使用该命令会自动调用"),a("code",[t._v("kubectl cordon <node>")]),t._v("命令。当该节点维护完成，启动了kubelet后，再使用"),a("code",[t._v("kubectl uncordon <node>")]),t._v("即可将该节点添加到kubernetes集群中。")]),t._v(" "),a("h2",{attrs:{id:"命名空间（namespace）"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#命名空间（namespace）","aria-hidden":"true"}},[t._v("#")]),t._v(" 命名空间（Namespace）")]),t._v(" "),a("p",[t._v("命名空间为Kubernetes集群提供虚拟的隔离作用，Kubernetes集群初始有两个命名空间，分别是默认命名空间default和系统命名空间kube-system，除此以外，管理员可以可以创建新的命名空间满足需要。")]),t._v(" "),a("p",[t._v("在一个Kubernetes集群中可以使用namespace创建多个“虚拟集群”，这些namespace之间可以完全隔离，也可以通过某种方式，让一个namespace中的service可以访问到其他的namespace中的服务，这需要通过RBAC定义集群级别的角色来实现。")]),t._v(" "),a("p",[a("strong",[t._v("哪些情况下适合使用多个namespace ?")])]),t._v(" "),a("p",[t._v("因为namespace可以提供独立的命名空间，因此可以实现部分的环境隔离。当你的项目和人员众多的时候可以考虑根据项目属性，例如生产、测试、开发划分不同的namespace。")]),t._v(" "),a("h3",{attrs:{id:"namespace使用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#namespace使用","aria-hidden":"true"}},[t._v("#")]),t._v(" Namespace使用")]),t._v(" "),a("p",[a("strong",[t._v("获取集群中有哪些namespace")])]),t._v(" "),a("div",{staticClass:"language-bash extra-class"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[t._v("$ kubectl get ns\n")])])]),a("p",[t._v("集群中默认会有"),a("code",[t._v("default")]),t._v("和"),a("code",[t._v("kube-system")]),t._v("这两个namespace。")]),t._v(" "),a("p",[t._v("在执行"),a("code",[t._v("kubectl")]),t._v("命令时可以使用"),a("code",[t._v("-n")]),t._v("指定操作的namespace。")]),t._v(" "),a("p",[t._v("用户的普通应用默认是在"),a("code",[t._v("default")]),t._v("下，与集群管理相关的为整个集群提供服务的应用一般部署在"),a("code",[t._v("kube-system")]),t._v("的namespace下，例如我们在安装kubernetes集群时部署的"),a("code",[t._v("kubedns")]),t._v("、"),a("code",[t._v("heapseter")]),t._v("、"),a("code",[t._v("EFK")]),t._v("等都是在这个namespace下面。")]),t._v(" "),a("p",[t._v("另外，并不是所有的资源对象都会对应namespace，"),a("code",[t._v("node")]),t._v("和"),a("code",[t._v("persistentVolume")]),t._v("就不属于任何namespace。")]),t._v(" "),a("h2",{attrs:{id:"pod"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#pod","aria-hidden":"true"}},[t._v("#")]),t._v(" Pod")]),t._v(" "),a("p",[t._v("Kubernetes有很多技术概念，同时对应很多API对象，最重要的也是最基础的是Pod。Pod是在Kubernetes集群中运行部署应用或服务的最小单元，它是可以支持多容器的。Pod的设计理念是支持多个容器在一个Pod中共享网络地址和文件系统，可以通过进程间通信和文件共享这种简单高效的方式组合完成服务。Pod对多容器的支持是K8最基础的设计理念。比如你运行一个操作系统发行版的软件仓库，一个Nginx容器用来发布软件，另一个容器专门用来从源仓库做同步，这两个容器的镜像不太可能是一个团队开发的，但是他们一块儿工作才能提供一个微服务；这种情况下，不同的团队各自开发构建自己的容器镜像，在部署的时候组合成一个微服务对外提供服务。")]),t._v(" "),a("p",[t._v("Pod是Kubernetes集群中所有业务类型的基础，可以看作运行在Kubernetes集群中的小机器人，不同类型的业务就需要不同类型的小机器人去执行。目前Kubernetes中的业务主要可以分为长期伺服型（long-running）、批处理型（batch）、节点后台支撑型（node-daemon）和有状态应用型（stateful application）；分别对应的小机器人控制器为Deployment、Job、DaemonSet和StatefulSet，本文后面会一一介绍。")]),t._v(" "),a("h3",{attrs:{id:"什么是pod"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是pod","aria-hidden":"true"}},[t._v("#")]),t._v(" 什么是Pod")]),t._v(" "),a("p",[t._v("Pod是kubernetes中你可以创建和部署的最小也是最简的单位。Pod代表着集群中运行的进程。")]),t._v(" "),a("p",[t._v("Pod就像是豌豆荚一样，它由一个或者多个容器组成（例如Docker容器），它们共享容器存储、网络和容器运行配置项。Pod中的容器总是被同时调度，有共同的运行环境。你可以把单个Pod想象成是运行独立应用的“逻辑主机”——其中运行着一个或者多个紧密耦合的应用容器——在有容器之前，这些应用都是运行在几个相同的物理机或者虚拟机上。")]),t._v(" "),a("p",[t._v("尽管kubernetes支持多种容器运行时，但是Docker依然是最常用的运行时环境，我们可以使用Docker的术语和规则来定义Pod。")]),t._v(" "),a("p",[t._v("Pod中共享的环境包括Linux的namespace、cgroup和其他可能的隔绝环境，这一点跟Docker容器一致。在Pod的环境中，每个容器中可能还有更小的子隔离环境。")]),t._v(" "),a("p",[t._v("Pod中的容器共享IP地址和端口号，它们之间可以通过localhost互相发现。它们之间可以通过进程间通信，例如SystemV信号或者POSIX共享内存。不同Pod之间的容器具有不同的IP地址，不能直接通过IPC通信。")]),t._v(" "),a("p",[t._v("Pod中的容器也有访问共享volume的权限，这些volume会被定义成pod的一部分并挂载到应用容器的文件系统中。")]),t._v(" "),a("p",[t._v("根据Docker的结构，Pod中的容器共享namespace和volume，不支持共享PID的namespace。")]),t._v(" "),a("p",[t._v("就像每个应用容器，pod被认为是临时（非持久的）实体。在Pod的生命周期中讨论过，pod被创建后，被分配一个唯一的ID（UID），调度到节点上，并一致维持期望的状态直到被终结（根据重启策略）或者被删除。如果node死掉了，分配到了这个node上的pod，在经过一个超时时间后会被重新调度到其他node节点上。一个给定的pod（如UID定义的）不会被“重新调度”到新的节点上，而是被一个同样的pod取代，如果期望的话甚至可以是相同的名字，但是会有一个新的UID。")]),t._v(" "),a("p",[t._v("Volume跟pod有相同的生命周期（当其UID存在的时候）。当Pod因为某种原因被删除或者被新创建的相同的Pod取代，它相关的东西（例如volume）也会被销毁和再创建一个新的volume。")]),t._v(" "),a("p",[t._v("Pod中封装着应用的容器（有的情况下是好几个容器），存储、独立的网络IP，管理容器如何运行的策略选项。Pod代表着部署的一个单位：kubernetes中应用的一个实例，可能由一个或者多个容器组合在一起共享资源。")]),t._v(" "),a("blockquote",[a("p",[a("a",{attrs:{href:"https://www.docker.com/",target:"_blank",rel:"noopener noreferrer"}},[t._v("Docker"),a("OutboundLink")],1),t._v("是kubernetes中最常用的容器运行时，但是Pod也支持其他容器运行时。")])]),t._v(" "),a("p",[t._v("在Kubernetes集群中Pod有如下两种使用方式：")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("一个Pod中运行一个容器")]),t._v("。“每个Pod中一个容器”的模式是最常见的用法；在这种使用方式中，你可以把Pod想象成是单个容器的封装，kuberentes管理的是Pod而不是直接管理容器。")]),t._v(" "),a("li",[a("strong",[t._v("在一个Pod中同时运行多个容器")]),t._v("。一个Pod中也可以同时封装几个需要紧密耦合互相协作的容器，它们之间共享资源。这些在同一个Pod中的容器可以互相协作成为一个service单位——一个容器共享文件，另一个“sidecar”容器来更新这些文件。Pod将这些容器的存储资源作为一个实体来管理。")])]),t._v(" "),a("p",[t._v("每个Pod都是应用的一个实例。如果你想平行扩展应用的话（运行多个实例），你应该运行多个Pod，每个Pod都是一个应用实例。在Kubernetes中，这通常被称为replication。")]),t._v(" "),a("h3",{attrs:{id:"pod中管理多个容器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#pod中管理多个容器","aria-hidden":"true"}},[t._v("#")]),t._v(" Pod中管理多个容器")]),t._v(" "),a("p",[t._v("Pod中可以同时运行多个进程（作为容器运行）协同工作。同一个Pod中的容器会自动的分配到同一个 node 上。同一个Pod中的容器共享资源、网络环境和依赖，它们总是被同时调度。")]),t._v(" "),a("p",[t._v("注意在一个Pod中同时运行多个容器是一种比较高级的用法。只有当你的容器需要紧密配合协作的时候才考虑用这种模式。例如，你有一个容器作为web服务器运行，需要用到共享的volume，有另一个“sidecar”容器来从远端获取资源更新这些文件，如下图所示：")]),t._v(" "),a("imgLink",{attrs:{src:"date/20190402/pod-overview.png"}}),t._v(" "),a("p",[t._v("Pod中可以共享两种资源：网络和存储。")]),t._v(" "),a("p",[a("strong",[t._v("网络")])]),t._v(" "),a("p",[t._v("每个Pod都会被分配一个唯一的IP地址。Pod中的所有容器共享网络空间，包括IP地址和端口。Pod内部的容器可以使用localhost互相通信。Pod中的容器与外界通信时，必须分配共享网络资源（例如使用宿主机的端口映射）。")]),t._v(" "),a("p",[a("strong",[t._v("存储")])]),t._v(" "),a("p",[t._v("可以为一个Pod指定多个共享的Volume。Pod中的所有容器都可以访问共享的volume。Volume也可以用来持久化Pod中的存储资源，以防容器重启后文件丢失。")]),t._v(" "),a("h3",{attrs:{id:"pod的使用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#pod的使用","aria-hidden":"true"}},[t._v("#")]),t._v(" Pod的使用")]),t._v(" "),a("p",[t._v("你很少会直接在kubernetes中创建单个Pod。因为Pod的生命周期是短暂的，用后即焚的实体。当Pod被创建后（不论是由你直接创建还是被其他Controller），都会被Kubernetes调度到集群的Node上。直到Pod的进程终止、被删掉、因为缺少资源而被驱逐、或者Node故障之前这个Pod都会一直保持在那个Node上。")]),t._v(" "),a("p",[t._v("::: warning 注意\n重启Pod中的容器跟重启Pod不是一回事。Pod只提供容器的运行环境并保持容器的运行状态，重启容器不会造成Pod重启。\n:::")]),t._v(" "),a("p",[t._v("Pod不会自愈。如果Pod运行的Node故障，或者是调度器本身故障，这个Pod就会被删除。同样的，如果Pod所在Node缺少资源或者Pod处于维护状态，Pod也会被驱逐。Kubernetes使用更高级的称为Controller的抽象层，来管理Pod实例。虽然可以直接使用Pod，但是在Kubernetes中通常是使用Controller来管理Pod的。")]),t._v(" "),a("p",[t._v("Pod也可以用于垂直应用栈（例如LAMP），这样使用的主要动机是为了支持共同调度和协调管理应用程序，例如：")]),t._v(" "),a("ul",[a("li",[t._v("内容管理系统、文件和数据加载器、本地换群管理器等。")]),t._v(" "),a("li",[t._v("日志和检查点备份、压缩、旋转、快照等。")]),t._v(" "),a("li",[t._v("数据变更观察者、日志和监控适配器、活动发布者等。")]),t._v(" "),a("li",[t._v("代理、桥接和适配器等。")]),t._v(" "),a("li",[t._v("控制器、管理器、配置器、更新器等。")])]),t._v(" "),a("p",[t._v("通常单个pod中不会同时运行一个应用的多个实例。")]),t._v(" "),a("h3",{attrs:{id:"pod-的生命周期"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#pod-的生命周期","aria-hidden":"true"}},[t._v("#")]),t._v(" Pod 的生命周期")]),t._v(" "),a("p",[t._v("下图是Pod的生命周期示意图，从图中可以看到Pod状态的变化。")]),t._v(" "),a("imgLink",{attrs:{src:"date/20190402/kubernetes-pod-life-cycle.jpg"}}),t._v(" "),a("p",[t._v("Pod 的生命周期包括:")]),t._v(" "),a("ul",[a("li",[t._v("挂起（Pending）：Pod 已被 Kubernetes 系统接受，但有一个或者多个容器镜像尚未创建。等待时间包括调度 Pod 的时间和通过网络下载镜像的时间，这可能需要花点时间。")]),t._v(" "),a("li",[t._v("运行中（Running）：该 Pod 已经绑定到了一个节点上，Pod 中所有的容器都已被创建。至少有一个容器正在运行，或者正处于启动或重启状态。")]),t._v(" "),a("li",[t._v("成功（Succeeded）：Pod 中的所有容器都被成功终止，并且不会再重启。")]),t._v(" "),a("li",[t._v("失败（Failed）：Pod 中的所有容器都已终止了，并且至少有一个容器是因为失败终止。也就是说，容器以非0状态退出或者被系统终止。")]),t._v(" "),a("li",[t._v("未知（Unknown）：因为某些原因无法取得 Pod 的状态，通常是因为与 Pod 所在主机通信失败。")])]),t._v(" "),a("h3",{attrs:{id:"pod-hook"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#pod-hook","aria-hidden":"true"}},[t._v("#")]),t._v(" Pod hook")]),t._v(" "),a("p",[t._v("Pod hook（钩子）是由Kubernetes管理的kubelet发起的，当容器中的进程启动前或者容器中的进程终止之前运行，这是包含在容器的生命周期之中。可以同时为Pod中的所有容器都配置hook。")]),t._v(" "),a("p",[t._v("Hook的类型包括两种：")]),t._v(" "),a("ul",[a("li",[t._v("exec：执行一段命令")]),t._v(" "),a("li",[t._v("HTTP：发送HTTP请求。")])]),t._v(" "),a("p",[t._v("参考下面的配置：")]),t._v(" "),a("div",{staticClass:"language-yaml extra-class"},[a("pre",{pre:!0,attrs:{class:"language-yaml"}},[a("code",[a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("apiVersion")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" v1\n"),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("kind")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" Pod\n"),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("metadata")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("name")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" lifecycle"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v("demo\n"),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("spec")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("containers")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("name")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" lifecycle"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v("demo"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v("container\n    "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("image")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" nginx\n    "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("lifecycle")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n      "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("postStart")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("exec")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n          "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("command")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"/bin/sh"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"-c"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"echo Hello from the postStart handler > /usr/share/message"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n      "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("preStop")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("exec")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n          "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("command")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"/usr/sbin/nginx"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"-s"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"quit"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n")])])]),a("p",[t._v("在容器创建之后，容器的Entrypoint执行之前，这时候Pod已经被调度到某台node上，被某个kubelet管理了，这时候kubelet会调用postStart操作，该操作跟容器的启动命令是在异步执行的，也就是说在postStart操作执行完成之前，kubelet会锁住容器，不让应用程序的进程启动，只有在 postStart操作完成之后容器的状态才会被设置成为RUNNING。")]),t._v(" "),a("p",[t._v("如果postStart或者preStop hook失败，将会终止容器。")]),t._v(" "),a("h3",{attrs:{id:"pod-preset"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#pod-preset","aria-hidden":"true"}},[t._v("#")]),t._v(" Pod Preset")]),t._v(" "),a("p",[t._v("Preset 就是预设，有时候想要让一批容器在启动的时候就注入一些信息，比如 secret、volume、volume mount 和环境变量，而又不想一个一个的改这些 Pod 的 template，这时候就可以用到 PodPreset 这个资源对象了。")]),t._v(" "),a("p",[t._v("Pod Preset 是用来在 Pod 被创建的时候向其中注入额外的运行时需求的 API 资源。")]),t._v(" "),a("p",[t._v("使用 Pod Preset 使得 pod 模板的作者可以不必为每个 Pod 明确提供所有信息。这样一来，pod 模板的作者就不需要知道关于该服务的所有细节。")]),t._v(" "),a("h3",{attrs:{id:"init-容器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#init-容器","aria-hidden":"true"}},[t._v("#")]),t._v(" Init 容器")]),t._v(" "),a("p",[t._v("Pod 能够具有多个容器，应用运行在容器里面，但是它也可能有一个或多个先于应用容器启动的 Init 容器。")]),t._v(" "),a("p",[t._v("Init 容器与普通的容器非常像，除了如下两点：")]),t._v(" "),a("ul",[a("li",[t._v("Init 容器总是运行到成功完成为止。")]),t._v(" "),a("li",[t._v("每个 Init 容器都必须在下一个 Init 容器启动之前成功完成。")])]),t._v(" "),a("p",[t._v("如果 Pod 的 Init 容器失败，Kubernetes 会不断地重启该 Pod，直到 Init 容器成功为止。然而，如果 Pod 对应的 restartPolicy 为 Never，它不会重新启动。")]),t._v(" "),a("p",[t._v("指定容器为 Init 容器，在 PodSpec 中添加 initContainers 字段，以 v1.Container 类型对象的 JSON 数组的形式，还有 app 的 containers 数组。 Init 容器的状态在 status.initContainerStatuses 字段中以容器状态数组的格式返回（类似 status.containerStatuses 字段）。")]),t._v(" "),a("h4",{attrs:{id:"使用-init-容器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用-init-容器","aria-hidden":"true"}},[t._v("#")]),t._v(" 使用 Init 容器")]),t._v(" "),a("p",[t._v("以下是 Kubernetes 1.6 版本的新语法，尽管老的 annotation 语法仍然可以使用。我们已经把 Init 容器的声明移到 "),a("code",[t._v("spec")]),t._v(" 中：")]),t._v(" "),a("p",[a("code",[t._v("myapp.yaml")])]),t._v(" "),a("div",{staticClass:"language-yaml extra-class"},[a("pre",{pre:!0,attrs:{class:"language-yaml"}},[a("code",[a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("apiVersion")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" v1\n"),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("kind")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" Pod\n"),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("metadata")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("name")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" myapp"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v("pod\n  "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("labels")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("app")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" myapp\n"),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("spec")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("containers")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("name")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" myapp"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v("container\n    "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("image")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" busybox\n    "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("command")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'sh'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'-c'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'echo The app is running! && sleep 3600'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("initContainers")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("name")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" init"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v("myservice\n    "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("image")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" busybox\n    "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("command")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'sh'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'-c'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'until nslookup myservice; do echo waiting for myservice; sleep 2; done;'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("name")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" init"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v("mydb\n    "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("image")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" busybox\n    "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("command")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'sh'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'-c'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'until nslookup mydb; do echo waiting for mydb; sleep 2; done;'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n")])])]),a("p",[t._v("下面的 YAML 文件展示了包括 "),a("code",[t._v("mydb")]),t._v(" 和 "),a("code",[t._v("myservice")]),t._v(" 两个 Service：")]),t._v(" "),a("p",[a("code",[t._v("services.yaml")])]),t._v(" "),a("div",{staticClass:"language-yaml extra-class"},[a("pre",{pre:!0,attrs:{class:"language-yaml"}},[a("code",[a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("kind")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" Service\n"),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("apiVersion")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" v1\n"),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("metadata")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("name")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" myservice\n"),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("spec")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("ports")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("protocol")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" TCP\n      "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("port")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("80")]),t._v("\n      "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("targetPort")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("9376")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("---")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("kind")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" Service\n"),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("apiVersion")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" v1\n"),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("metadata")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("name")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" mydb\n"),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("spec")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("ports")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("protocol")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" TCP\n      "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("port")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("80")]),t._v("\n      "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("targetPort")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("9377")]),t._v("\n")])])]),a("p",[t._v("这个 Pod 可以使用下面的命令进行启动和调试：")]),t._v(" "),a("div",{staticClass:"language-bash extra-class"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[t._v("$ kubectl create -f myapp.yaml\npod "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"myapp-pod"')]),t._v(" created\n$ kubectl get -f myapp.yaml\nNAME        READY     STATUS     RESTARTS   AGE\nmyapp-pod   0/1       Init:0/2   0          6m\n$ kubectl describe -f myapp.yaml\nName:          myapp-pod\nNamespace:     default\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("..")]),t._v("."),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\nLabels:        app"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("myapp\nStatus:        Pending\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("..")]),t._v("."),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\nInit Containers:\n  init-myservice:\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("..")]),t._v("."),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n    State:         Running\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("..")]),t._v("."),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n  init-mydb:\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("..")]),t._v("."),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n    State:         Waiting\n      Reason:      PodInitializing\n    Ready:         False\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("..")]),t._v("."),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\nContainers:\n  myapp-container:\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("..")]),t._v("."),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n    State:         Waiting\n      Reason:      PodInitializing\n    Ready:         False\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("..")]),t._v("."),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\nEvents:\n  FirstSeen    LastSeen    Count    From                      SubObjectPath                           Type          Reason        Message\n  ---------    --------    -----    ----                      -------------                           --------      ------        -------\n  16s          16s         1        "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("default-scheduler "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("                                              Normal        Scheduled     Successfully assigned myapp-pod to 172.17.4.201\n  16s          16s         1        "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("kubelet 172.17.4.201"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("    spec.initContainers"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("init-myservice"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("     Normal        Pulling       pulling image "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"busybox"')]),t._v("\n  13s          13s         1        "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("kubelet 172.17.4.201"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("    spec.initContainers"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("init-myservice"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("     Normal        Pulled        Successfully pulled image "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"busybox"')]),t._v("\n  13s          13s         1        "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("kubelet 172.17.4.201"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("    spec.initContainers"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("init-myservice"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("     Normal        Created       Created container with docker "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("id")]),t._v(" 5ced34a04634"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" Security:"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("seccomp"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("unconfined"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n  13s          13s         1        "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("kubelet 172.17.4.201"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("    spec.initContainers"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("init-myservice"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("     Normal        Started       Started container with docker "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("id")]),t._v(" 5ced34a04634\n$ kubectl logs myapp-pod -c init-myservice "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Inspect the first init container")]),t._v("\n$ kubectl logs myapp-pod -c init-mydb      "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Inspect the second init container")]),t._v("\n")])])]),a("p",[t._v("可以看到, 在 "),a("code",[t._v("mydb")]),t._v(" 和 "),a("code",[t._v("myservice")]),t._v(" 服务还未创建之前, STATUS 为 "),a("code",[t._v("Init:0/2")]),t._v(", 处于等待服务创建的阶段。")]),t._v(" "),a("p",[t._v("一旦我们启动了 "),a("code",[t._v("mydb")]),t._v(" 和 "),a("code",[t._v("myservice")]),t._v(" 这两个 Service，我们能够看到 Init 容器完成，并且 "),a("code",[t._v("myapp-pod")]),t._v(" 被创建, 其状态为 "),a("code",[t._v("Running")]),t._v("：")]),t._v(" "),a("div",{staticClass:"language-bash extra-class"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[t._v("$ kubectl create -f services.yaml\n"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("service")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"myservice"')]),t._v(" created\n"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("service")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"mydb"')]),t._v(" created\n$ kubectl get -f myapp.yaml\nNAME        READY     STATUS    RESTARTS   AGE\nmyapp-pod   1/1       Running   0          9m\n")])])]),a("p",[t._v("这个例子非常简单，但是应该能够为我们创建自己的 Init 容器提供一些启发。")]),t._v(" "),a("h3",{attrs:{id:"api-object"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#api-object","aria-hidden":"true"}},[t._v("#")]),t._v(" API Object")]),t._v(" "),a("p",[t._v("Pod是kubernetes REST API中的顶级资源类型。")]),t._v(" "),a("p",[t._v("在kuberentes1.6的V1 core API版本中的Pod的数据结构如下图所示：")]),t._v(" "),a("imgLink",{attrs:{src:"date/20190402/kubernetes-pod-cheatsheet.png"}}),t._v(" "),a("h2",{attrs:{id:"副本控制器（replication-controller，rc）"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#副本控制器（replication-controller，rc）","aria-hidden":"true"}},[t._v("#")]),t._v(" 副本控制器（Replication Controller，RC）")]),t._v(" "),a("p",[t._v("RC是Kubernetes集群中最早的保证Pod高可用的API对象。通过监控运行中的Pod来保证集群中运行指定数目的Pod副本。指定的数目可以是多个也可以是1个；少于指定数目，RC就会启动运行新的Pod副本；多于指定数目，RC就会杀死多余的Pod副本。即使在指定数目为1的情况下，通过RC运行Pod也比直接运行Pod更明智，因为RC也可以发挥它高可用的能力，保证永远有1个Pod在运行。RC是Kubernetes较早期的技术概念，只适用于长期伺服型的业务类型，比如控制小机器人提供高可用的Web服务。")]),t._v(" "),a("h2",{attrs:{id:"副本集（replica-set，rs）"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#副本集（replica-set，rs）","aria-hidden":"true"}},[t._v("#")]),t._v(" 副本集（Replica Set，RS）")]),t._v(" "),a("p",[t._v("RS是新一代RC，提供同样的高可用能力，区别主要在于RS后来居上，能支持更多种类的匹配模式。副本集对象一般不单独使用，而是作为Deployment的理想状态参数使用。")]),t._v(" "),a("h2",{attrs:{id:"部署（deployment）"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#部署（deployment）","aria-hidden":"true"}},[t._v("#")]),t._v(" 部署（Deployment）")]),t._v(" "),a("p",[t._v("部署表示用户对Kubernetes集群的一次更新操作。部署是一个比RS应用模式更广的API对象，可以是创建一个新的服务，更新一个新的服务，也可以是滚动升级一个服务。滚动升级一个服务，实际是创建一个新的RS，然后逐渐将新RS中副本数增加到理想状态，将旧RS中的副本数减小到0的复合操作；这样一个复合操作用一个RS是不太好描述的，所以用一个更通用的Deployment来描述。以Kubernetes的发展方向，未来对所有长期伺服型的的业务的管理，都会通过Deployment来管理。")]),t._v(" "),a("h2",{attrs:{id:"服务（service）"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#服务（service）","aria-hidden":"true"}},[t._v("#")]),t._v(" 服务（Service）")]),t._v(" "),a("p",[t._v("RC、RS和Deployment只是保证了支撑服务的微服务Pod的数量，但是没有解决如何访问这些服务的问题。一个Pod只是一个运行服务的实例，随时可能在一个节点上停止，在另一个节点以一个新的IP启动一个新的Pod，因此不能以确定的IP和端口号提供服务。要稳定地提供服务需要服务发现和负载均衡能力。服务发现完成的工作，是针对客户端访问的服务，找到对应的的后端服务实例。在K8集群中，客户端需要访问的服务就是Service对象。每个Service会对应一个集群内部有效的虚拟IP，集群内部通过虚拟IP访问一个服务。在Kubernetes集群中微服务的负载均衡是由Kube-proxy实现的。Kube-proxy是Kubernetes集群内部的负载均衡器。它是一个分布式代理服务器，在Kubernetes的每个节点上都有一个；这一设计体现了它的伸缩性优势，需要访问服务的节点越多，提供负载均衡能力的Kube-proxy就越多，高可用节点也随之增多。与之相比，我们平时在服务器端做个反向代理做负载均衡，还要进一步解决反向代理的负载均衡和高可用问题。")]),t._v(" "),a("h2",{attrs:{id:"存储卷（volume）"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#存储卷（volume）","aria-hidden":"true"}},[t._v("#")]),t._v(" 存储卷（Volume）")]),t._v(" "),a("p",[t._v("Kubernetes集群中的存储卷跟Docker的存储卷有些类似，只不过Docker的存储卷作用范围为一个容器，而Kubernetes的存储卷的生命周期和作用范围是一个Pod。每个Pod中声明的存储卷由Pod中的所有容器共享。Kubernetes支持非常多的存储卷类型，特别的，支持多种公有云平台的存储，包括AWS，Google和Azure云；支持多种分布式存储包括GlusterFS和Ceph；也支持较容易使用的主机本地目录emptyDir, hostPath和NFS。Kubernetes还支持使用Persistent Volume Claim即PVC这种逻辑存储，使用这种存储，使得存储的使用者可以忽略后台的实际存储技术（例如AWS，Google或GlusterFS和Ceph），而将有关存储实际技术的配置交给存储管理员通过Persistent Volume来配置。")]),t._v(" "),a("h2",{attrs:{id:"持久存储卷（persistent-volume，pv）和持久存储卷声明（persistent-volume-claim，pvc）"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#持久存储卷（persistent-volume，pv）和持久存储卷声明（persistent-volume-claim，pvc）","aria-hidden":"true"}},[t._v("#")]),t._v(" 持久存储卷（Persistent Volume，PV）和持久存储卷声明（Persistent Volume Claim，PVC）")]),t._v(" "),a("p",[t._v("PV和PVC使得Kubernetes集群具备了存储的逻辑抽象能力，使得在配置Pod的逻辑里可以忽略对实际后台存储技术的配置，而把这项配置的工作交给PV的配置者，即集群的管理者。存储的PV和PVC的这种关系，跟计算的Node和Pod的关系是非常类似的；PV和Node是资源的提供者，根据集群的基础设施变化而变化，由Kubernetes集群管理员配置；而PVC和Pod是资源的使用者，根据业务服务的需求变化而变化，有Kubernetes集群的使用者即服务的管理员来配置。")]),t._v(" "),a("h2",{attrs:{id:"密钥对象（secret）"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#密钥对象（secret）","aria-hidden":"true"}},[t._v("#")]),t._v(" 密钥对象（Secret）")]),t._v(" "),a("p",[t._v("Secret是用来保存和传递密码、密钥、认证凭证这些敏感信息的对象。使用Secret的好处是可以避免把敏感信息明文写在配置文件里。在Kubernetes集群中配置和使用服务不可避免的要用到各种敏感信息实现登录、认证等功能，例如访问AWS存储的用户名密码。为了避免将类似的敏感信息明文写在所有需要使用的配置文件中，可以将这些信息存入一个Secret对象，而在配置文件中通过Secret对象引用这些敏感信息。这种方式的好处包括：意图明确，避免重复，减少暴漏机会。")])],1)},[],!1,null,null,null);e.default=n.exports}}]);