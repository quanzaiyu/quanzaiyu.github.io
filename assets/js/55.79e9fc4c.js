(window.webpackJsonp=window.webpackJsonp||[]).push([[55],{398:function(t,e,r){"use strict";r.r(e);var s=r(1),i=Object(s.a)({},function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("div",{staticClass:"content"},[t._m(0),t._v(" "),t._m(1),t._v(" "),t._m(2),t._v(" "),t._m(3),t._v(" "),r("p",[t._v("我们都知道，操作系统分为内核和用户空间。对于 Linux 而言，内核启动后，会挂载 root 文件系统为其提供用户空间支持。而 Docker 镜像（Image），就相当于是一个 root 文件系统。比如官方镜像 ubuntu:16.04 就包含了完整的一套 Ubuntu 16.04 最小系统的 root 文件系统。")]),t._v(" "),r("p",[t._v("Docker 镜像是Docker容器运行时的只读模板，每一个镜像有一些列的层（layers）组成。Docker使用UnionFS来将这些层联合到单独的镜像中。UnionFS允许独立于文件系统中的文件和文件夹（称之为分支）被透明覆盖，形成一个单独连贯的文件系统。正因为有了这些层的存在，Docker是如此的轻量。")]),t._v(" "),r("imgLink",{attrs:{src:"date/20181013/001.png"}}),t._v(" "),r("p",[t._v("当你改变了一个Docker镜像，比如升级到某个程序到新的版本，一个新的层就会被创建。因此，不用替换整个原先的镜像或者重新建立（在使用虚拟机的时候你可能会这么做），只是一个新的层被添加或者升级了。现在你不用重新发布整个镜像，只需要升级，层使得分发Docker镜像变得简单和快速。")]),t._v(" "),r("p",[t._v("在 Docker Store 上有非常多的高质量的官方镜像，有可以直接拿来使用的服务类的镜像，如 nginx、redis、mongo、mysql、httpd、php、tomcat 等；也有一些方便开发、构建、运行各种语言应用的镜像，如 node、openjdk、python、ruby、golang 等。可以在其中寻找一个最符合我们最终目标的镜像为基础镜像进行定制。")]),t._v(" "),r("p",[t._v("如果没有找到对应服务的镜像，官方镜像中还提供了一些更为基础的操作系统镜像，如 ubuntu、debian、centos、fedora、alpine 等，这些操作系统的软件库为我们提供了更广阔的扩展空间。")]),t._v(" "),r("p",[t._v("除了选择现有镜像为基础镜像外，Docker 还存在一个特殊的镜像，名为 scratch。这个镜像是虚拟的概念，并不实际存在，它表示一个空白的镜像。")]),t._v(" "),t._m(4),t._v(" "),r("p",[t._v("Docker容器和文件夹很类似，一个Docker容器包含了所有的某个应用运行所需要的环境。每一个Docker容器都是从Docker镜像创建的。Docker容器可以运行、开始、停止、移动和删除。每一个Docker容器都是单独和安全的应用平台，Docker容器是Docker的运行部分。")]),t._v(" "),r("p",[t._v("镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的 类 和 实例 一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。")]),t._v(" "),r("p",[t._v("容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的 命名空间。因此容器可以拥有自己的 root 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。这种特性使得容器封装的应用比直接在宿主运行更加安全。也因为这种隔离的特性，很多人初学 Docker 时常常会混淆容器和虚拟机。")]),t._v(" "),r("p",[t._v("每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，我们可以称这个为容器运行时读写而准备的存储层为容器存储层。")]),t._v(" "),r("p",[t._v("容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。")]),t._v(" "),r("imgLink",{attrs:{src:"date/20181013/002.png"}}),t._v(" "),r("p",[t._v("要点：容器 = 镜像 + 读写层。并且容器的定义并没有提及是否要运行容器。")]),t._v(" "),t._m(5),t._v(" "),r("p",[t._v("一个运行态容器（running container）被定义为一个可读写的统一文件系统加上隔离的进程空间和包含其中的进程。")]),t._v(" "),r("imgLink",{attrs:{src:"date/20181013/003.png"}}),t._v(" "),t._m(6),t._v(" "),r("p",[t._v("镜像构建完成后，可以很容易的在当前宿主机上运行，但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，Docker 仓库就是这样的服务。")]),t._v(" "),r("p",[t._v("Docker 仓库用来保存镜像，可以理解为代码控制中的代码仓库。同样的，Docker仓库也有公有和私有的概念。共有的Docker仓库名字是Docker Hub。Docker Hub提供了庞大的镜像集合供使用。这些镜像可以是自己创建，或者在别人的镜像基础上创建。Docker仓库是Docker的分发部分。")]),t._v(" "),r("p",[t._v("一个 Docker 仓库中可以包含多个仓库（Repository）；每个仓库可以包含多个标签（Tag）；每个标签对应一个镜像。")]),t._v(" "),t._m(7),t._v(" "),t._m(8),t._v(" "),t._m(9),t._v(" "),t._m(10),t._v(" "),r("p",[t._v("Control Groups 用来分配资源，此技术来源于 Google，在2007年整合进 Linux Kernel 2.6.24 。")]),t._v(" "),r("p",[t._v("Control Groups 有以下作用：")]),t._v(" "),t._m(11),t._v(" "),t._m(12),t._v(" "),r("imgLink",{attrs:{src:"date/20181014/002.png"}}),t._v(" "),t._m(13),t._v(" "),t._m(14),t._v(" "),t._m(15),t._v(" "),t._m(16),t._v(" "),t._m(17),t._v(" "),t._m(18)],1)},[function(){var t=this.$createElement,e=this._self._c||t;return e("h1",{attrs:{id:"docker-核心概念"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#docker-核心概念","aria-hidden":"true"}},[this._v("#")]),this._v(" Docker 核心概念")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"docker-内部组件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#docker-内部组件","aria-hidden":"true"}},[this._v("#")]),this._v(" Docker 内部组件")])},function(){var t=this.$createElement,e=this._self._c||t;return e("ul",[e("li",[this._v("Docker 镜像 - Docker Image")]),this._v(" "),e("li",[this._v("Docker 容器 - Docker Containers")]),this._v(" "),e("li",[this._v("Dokcer 仓库 - Docker Registeries")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"docker-镜像"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#docker-镜像","aria-hidden":"true"}},[this._v("#")]),this._v(" Docker 镜像")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"docker-容器"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#docker-容器","aria-hidden":"true"}},[this._v("#")]),this._v(" Docker 容器")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("strong",[this._v("运行态容器")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"docker-仓库"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#docker-仓库","aria-hidden":"true"}},[this._v("#")]),this._v(" Docker 仓库")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"docker-依赖的相关技术"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#docker-依赖的相关技术","aria-hidden":"true"}},[this._v("#")]),this._v(" Docker 依赖的相关技术")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"namespaces-命名空间"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#namespaces-命名空间","aria-hidden":"true"}},[this._v("#")]),this._v(" Namespaces 命名空间")])},function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ul",[r("li",[t._v("PID（Process ID） 进程隔离")]),t._v(" "),r("li",[t._v("NET（Network） 管理网络接口")]),t._v(" "),r("li",[t._v("IPC（InterProcess Communication） 管理跨进程通信的访问")]),t._v(" "),r("li",[t._v("MNT（Mount） 管理挂载点")]),t._v(" "),r("li",[t._v("UTS（Unix Timesharing System） 隔离内核和版本标识")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"control-groups-控制组"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#control-groups-控制组","aria-hidden":"true"}},[this._v("#")]),this._v(" Control Groups 控制组")])},function(){var t=this.$createElement,e=this._self._c||t;return e("ul",[e("li",[this._v("资源限制")]),this._v(" "),e("li",[this._v("优先级设定")]),this._v(" "),e("li",[this._v("资源计量")]),this._v(" "),e("li",[this._v("资源控制")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"docker-的-c-s-模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#docker-的-c-s-模式","aria-hidden":"true"}},[this._v("#")]),this._v(" Docker 的 C/S 模式")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"remote-api"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#remote-api","aria-hidden":"true"}},[this._v("#")]),this._v(" Remote API")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"连接方式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#连接方式","aria-hidden":"true"}},[this._v("#")]),this._v(" 连接方式")])},function(){var t=this.$createElement,e=this._self._c||t;return e("ul",[e("li",[this._v("unix://var/run/docker.sock")]),this._v(" "),e("li",[this._v("tcp://host:port")]),this._v(" "),e("li",[this._v("fd://socketfd")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"docker-信息"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#docker-信息","aria-hidden":"true"}},[this._v("#")]),this._v(" Docker 信息")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("Docker 镜像存储位置："),e("code",[this._v("/var/lib/docker")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("使用 "),e("code",[this._v("docker info")]),this._v(" 可以查看关于 Docker 的一些信息。")])}],!1,null,null,null);i.options.__file="Core.md";e.default=i.exports}}]);