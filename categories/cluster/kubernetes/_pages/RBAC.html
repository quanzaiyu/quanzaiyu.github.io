<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Kubernetes 核心概念 - 角色的访问控制 (RBAC) | 小昱个人网站</title>
    <meta name="description" content="小昱个人网站">
    <meta http-equiv="Expires" content="Mon,12 May 2050 00:20:00 GMT">
  <meta name="keywords" content="小昱,个人网站,Vue,JavaScript,HTML,CSS">
  <link rel="icon" href="/logo.png">
  <link rel="manifest" href="/manifest.json">
  <link rel="stylesheet" href="//at.alicdn.com/t/font_517060_lom78h954w.css">
  <link rel="stylesheet" href="https://img.xiaoyulive.top/css/animate.css">
    
    <link rel="preload" href="/assets/css/0.styles.e2d81a46.css" as="style"><link rel="preload" href="/assets/js/app.25c87086.js" as="script"><link rel="preload" href="/assets/js/5.314447d8.js" as="script"><link rel="preload" href="/assets/js/14.1aec49d6.js" as="script"><link rel="prefetch" href="/assets/js/1.9661ddb3.js"><link rel="prefetch" href="/assets/js/10.730e6669.js"><link rel="prefetch" href="/assets/js/11.03a3b555.js"><link rel="prefetch" href="/assets/js/12.dea4259a.js"><link rel="prefetch" href="/assets/js/13.017d0ddc.js"><link rel="prefetch" href="/assets/js/15.54ee861e.js"><link rel="prefetch" href="/assets/js/2.6b7127f7.js"><link rel="prefetch" href="/assets/js/6.398530e5.js"><link rel="prefetch" href="/assets/js/7.b1fc2793.js"><link rel="prefetch" href="/assets/js/8.46eac014.js"><link rel="prefetch" href="/assets/js/9.c4f01555.js"><link rel="prefetch" href="/assets/js/vendors~docsearch.1d9f8a8b.js">
    <link rel="stylesheet" href="/assets/css/0.styles.e2d81a46.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container" data-v-38547c78><header class="navbar" data-v-38547c78><div class="navbar-content"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div><a href="/" class="home-link router-link-active"><img src="/logo.png" class="logo"><span class="site-name can-hide">小昱个人网站</span></a><div class="links"><nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/" class="nav-link">开发者博客</a></div><div class="nav-item"><a href="/articles/" class="nav-link">生活漫谈</a></div><div class="nav-item"><a href="/note/" class="nav-link">阅读札记</a></div><div class="nav-item"><a href="/categories/" class="nav-link router-link-active">学无止境</a></div><div class="nav-item"><a href="/share/" class="nav-link">精品分享</a></div><div class="nav-item"><a href="/favorite/" class="nav-link">收藏夹</a></div><!----></nav><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""><!----></div></div></div></header><div class="sidebar-mask" data-v-38547c78></div><div class="sidebar" data-v-38547c78><div class="sidebar-container"><nav class="nav-links"><div class="nav-item"><a href="/blog/" class="nav-link">开发者博客</a></div><div class="nav-item"><a href="/articles/" class="nav-link">生活漫谈</a></div><div class="nav-item"><a href="/note/" class="nav-link">阅读札记</a></div><div class="nav-item"><a href="/categories/" class="nav-link router-link-active">学无止境</a></div><div class="nav-item"><a href="/share/" class="nav-link">精品分享</a></div><div class="nav-item"><a href="/favorite/" class="nav-link">收藏夹</a></div><!----></nav><ul class="sidebar-links"><li><div class="sidebar-group first"><p class="sidebar-heading open"><span>Kubernetes 核心概念 - 角色的访问控制 (RBAC)</span> <!----></p> <ul class="sidebar-group-items"><li><a href="/categories/cluster/kubernetes/_pages/RBAC.html#rbac-api-对象" class="sidebar-link">RBAC API 对象</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/categories/cluster/kubernetes/_pages/RBAC.html#创建一个只能访问某个-namespace-的用户" class="sidebar-link">创建一个只能访问某个 namespace 的用户</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/categories/cluster/kubernetes/_pages/RBAC.html#_1-创建用户凭证" class="sidebar-link">1 创建用户凭证</a></li><li class="sidebar-sub-header"><a href="/categories/cluster/kubernetes/_pages/RBAC.html#_2-创建角色" class="sidebar-link">2 创建角色</a></li><li class="sidebar-sub-header"><a href="/categories/cluster/kubernetes/_pages/RBAC.html#_3-创建角色权限绑定" class="sidebar-link">3 创建角色权限绑定</a></li><li class="sidebar-sub-header"><a href="/categories/cluster/kubernetes/_pages/RBAC.html#_4-测试" class="sidebar-link">4 测试</a></li></ul></li><li><a href="/categories/cluster/kubernetes/_pages/RBAC.html#创建一个只能访问某个-namespace-的-serviceaccount" class="sidebar-link">创建一个只能访问某个 namespace 的 ServiceAccount</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/categories/cluster/kubernetes/_pages/RBAC.html#创建一个可以访问所有-namespace-的-serviceaccount" class="sidebar-link">创建一个可以访问所有 namespace 的 ServiceAccount</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/categories/cluster/kubernetes/_pages/RBAC.html#service-account" class="sidebar-link">Service Account</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/categories/cluster/kubernetes/_pages/RBAC.html#使用默认的-serviceaccount-访问-api-server" class="sidebar-link">使用默认的 ServiceAccount 访问 API server</a></li><li class="sidebar-sub-header"><a href="/categories/cluster/kubernetes/_pages/RBAC.html#serviceaccount-的常用操作" class="sidebar-link">ServiceAccount 的常用操作</a></li></ul></li><li><a href="/categories/cluster/kubernetes/_pages/RBAC.html#参考资料" class="sidebar-link">参考资料</a><ul class="sidebar-sub-headers"></ul></li></ul></div></li></ul></div></div><div class="page" data-v-38547c78><div class="content__default"><h1 id="kubernetes-核心概念-角色的访问控制-rbac"><a href="#kubernetes-核心概念-角色的访问控制-rbac" aria-hidden="true" class="header-anchor">#</a> Kubernetes 核心概念 - 角色的访问控制 (RBAC)</h1> <p>RBAC 使用 rbac.authorization.k8s.io API Group 来实现授权决策，允许管理员通过 Kubernetes API 动态配置策略，要启用 RBAC ，需要在 apiserver 中添加参数 --authorization-mode=RBAC ，如果使用的 kubeadm 安装的集群，1.6 版本以上的都默认开启了 RBAC ，可以通过查看 Master 节点上 apiserver 的静态 Pod 定义文件：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ <span class="token function">cat</span> /etc/kubernetes/manifests/kube-apiserver.yaml <span class="token operator">|</span> <span class="token function">grep</span> authorization-mode
    - --authorization-mode<span class="token operator">=</span>Node,RBAC
</code></pre></div><p>如果是二进制的方式搭建的集群，添加这个参数过后，记得要重启 apiserver 服务。</p> <h2 id="rbac-api-对象"><a href="#rbac-api-对象" aria-hidden="true" class="header-anchor">#</a> RBAC API 对象</h2> <p><code>Kubernetes</code> 有一个很基本的特性就是它的 <a href="https://www.colabug.com/goto/aHR0cHM6Ly9rdWJlcm5ldGVzLmlvL2RvY3MvY29uY2VwdHMvb3ZlcnZpZXcvd29ya2luZy13aXRoLW9iamVjdHMva3ViZXJuZXRlcy1vYmplY3RzLw==" target="_blank" rel="noopener noreferrer">所有资源对象都是模型化的 API 对象<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> ，允许执行 CRUD(Create、Read、Update、Delete)操作(也就是我们常说的增、删、改、查操作)，比如下面的这下资源：</p> <ul><li>Pods</li> <li>ConfigMaps</li> <li>Deployments</li> <li>Nodes</li> <li>Secrets</li> <li>Namespaces</li></ul> <p>上面这些资源对象的可能存在的操作有：</p> <ul><li>create</li> <li>get</li> <li>delete</li> <li>list</li> <li>update</li> <li>edit</li> <li>watch</li> <li>exec</li></ul> <p>在更上层，这些资源和 API Group 进行关联，比如 <code>Pods</code> 属于 Core API Group，而 <code>Deployements</code> 属于 apps API Group，要在 <code>Kubernetes</code> 中进行 <code>RBAC</code> 的管理，除了上面的这些资源和操作以外，我们还需要另外的一些对象：</p> <ul><li><strong>Rule</strong>：规则，规则是一组属于不同 API Group 资源上的一组操作的集合</li> <li><strong>Role 和 ClusterRole</strong>：角色和集群角色，这两个对象都包含上面的 Rules 元素，二者的区别在于，在 Role 中，定义的规则只适用于单个命名空间，也就是和 namespace 关联的，而 ClusterRole 是集群范围内的，因此定义的规则不受命名空间的约束。另外 Role 和 ClusterRole 在 <code>Kubernetes</code> 中都被定义为集群内部的 API 资源，和我们前面学习过的 Pod、ConfigMap 这些类似，都是我们集群的资源对象，所以同样的可以使用我们前面的 <code>kubectl</code> 相关的命令来进行操作</li> <li><strong>Subject</strong>：主题，对应在集群中尝试操作的对象</li> <li><strong>RoleBinding 和 ClusterRoleBinding</strong>：角色绑定和集群角色绑定，简单来说就是把声明的 Subject 和我们的 Role 进行绑定的过程(给某个用户绑定上操作的权限)，二者的区别也是作用范围的区别：RoleBinding 只会影响到当前 namespace 下面的资源操作权限，而 ClusterRoleBinding 会影响到所有的 namespace。</li></ul> <h2 id="创建一个只能访问某个-namespace-的用户"><a href="#创建一个只能访问某个-namespace-的用户" aria-hidden="true" class="header-anchor">#</a> 创建一个只能访问某个 namespace 的用户</h2> <p>我们来创建一个 User Account，只能访问 kube-system 这个命名空间：</p> <ul><li>username: qzy</li> <li>group: xiaoyulive</li></ul> <h3 id="_1-创建用户凭证"><a href="#_1-创建用户凭证" aria-hidden="true" class="header-anchor">#</a> 1 创建用户凭证</h3> <p>我们前面已经提到过， <code>Kubernetes</code> 没有 User Account 的 API 对象，不过要创建一个用户帐号的话也是挺简单的，利用管理员分配给你的一个私钥就可以创建了，这个我们可以参考 <a href="https://www.colabug.com/goto/aHR0cHM6Ly9rdWJlcm5ldGVzLmlvL2RvY3MvYWRtaW4vYXV0aGVudGljYXRpb24=" target="_blank" rel="noopener noreferrer">官方文档中的方法<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> ，这里我们来使用 <code>OpenSSL</code> 证书来创建一个 User，当然我们也可以使用更简单的 <code>cfssl</code> 工具来创建：</p> <p>给用户 qzy 创建一个私钥，命名成 <code>qzy.key</code></p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ openssl genrsa -out qzy.key 2048
Generating RSA private key, 2048 bit long modulus
<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>+++
<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>+++
e is 65537 <span class="token punctuation">(</span>0x10001<span class="token punctuation">)</span>
</code></pre></div><p>使用我们刚刚创建的私钥创建一个证书签名请求文件 <code>qzy.csr</code>，要注意需要确保在 <code>-subj</code> 参数中指定用户名和组(CN表示用户名，O表示组)：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ openssl req -new -key qzy.key -out qzy.csr -subj <span class="token string">&quot;/CN=qzy/O=xiaoyulive&quot;</span>
</code></pre></div><p>然后找到我们的 <code>Kubernetes</code> 集群的 <code>CA</code>，我使用的是 <code>kubeadm</code> 安装的集群， <code>CA</code> 相关证书位于 <code>/etc/kubernetes/pki/</code> 目录下面，如果你是二进制方式搭建的，你应该在最开始搭建集群的时候就已经指定好了 <code>CA</code> 的目录，我们会利用该目录下面的 <code>ca.crt</code> 和 <code>ca.key</code> 两个文件来批准上面的证书请求</p> <p>生成最终的证书文件，我们这里设置证书的有效期为500天：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ openssl x509 -req -in qzy.csr -CA /etc/kubernetes/pki/ca.crt -CAkey /etc/kubernetes/pki/ca.key -CAcreateserial -out qzy.crt -days 500
Signature ok
subject<span class="token operator">=</span>/CN<span class="token operator">=</span>qzy/O<span class="token operator">=</span>xiaoyulive
Getting CA Private Key
</code></pre></div><p>现在查看我们当前文件夹下面是否生成了一个证书文件</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ <span class="token function">ls</span>
qzy.crt  qzy.csr  qzy.key
</code></pre></div><p>现在我们可以使用刚刚创建的证书文件和私钥文件在集群中创建新的凭证和上下文(Context)</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ kubectl config set-credentials qzy --client-certificate<span class="token operator">=</span>qzy.crt  --client-key<span class="token operator">=</span>qzy.key
User <span class="token string">&quot;qzy&quot;</span> set.
</code></pre></div><p>我们可以看到一个用户 <code>qzy</code> 创建了，然后为这个用户设置新的 Context:</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ kubectl config set-context qzy-context --cluster<span class="token operator">=</span>kubernetes --namespace<span class="token operator">=</span>test --user<span class="token operator">=</span>qzy
Context <span class="token string">&quot;qzy-context&quot;</span> created.
</code></pre></div><p>到这里，我们的用户 <code>qzy</code> 就已经创建成功了，现在我们使用当前的这个配置文件来操作 <code>kubectl</code> 命令的时候，应该会出现错误，因为我们还没有为该用户定义任何操作的权限呢：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ kubectl get pods --context<span class="token operator">=</span>qzy-context
Error from server <span class="token punctuation">(</span>Forbidden<span class="token punctuation">)</span>: pods is forbidden: User <span class="token string">&quot;haimaxy&quot;</span> cannot list pods <span class="token keyword">in</span> the namespace <span class="token string">&quot;default&quot;</span>
</code></pre></div><h3 id="_2-创建角色"><a href="#_2-创建角色" aria-hidden="true" class="header-anchor">#</a> 2 创建角色</h3> <p>用户创建完成后，接下来就需要给该用户添加操作权限，我们来定义一个 <code>YAML</code> 文件，创建一个允许用户操作 Deployment、Pod、ReplicaSets 的角色，如下定义</p> <p><code>qzy-role.yaml</code></p> <div class="language-yaml extra-class"><pre class="language-yaml"><code><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> rbac.authorization.k8s.io/v1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> Role
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> qzy<span class="token punctuation">-</span>role <span class="token comment"># 角色名</span>
  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> test <span class="token comment"># 命名空间</span>
<span class="token key atrule">rules</span><span class="token punctuation">:</span>
<span class="token punctuation">-</span> <span class="token key atrule">apiGroups</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">&quot;&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;extensions&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;apps&quot;</span><span class="token punctuation">]</span> <span class="token comment"># API Group</span>
  <span class="token key atrule">resources</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">&quot;deployments&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;replicasets&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;pods&quot;</span><span class="token punctuation">]</span> <span class="token comment"># 允许访问的资源, 若允许访问全部资源可使用 [&quot;*&quot;]</span>
  <span class="token key atrule">verbs</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">&quot;get&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;list&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;watch&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;create&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;update&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;patch&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;delete&quot;</span><span class="token punctuation">]</span> <span class="token comment"># 允许的访问方式, 也可以使用[&quot;*&quot;]</span>
</code></pre></div><p>其中 <code>Pod</code> 属于 core 这个 API Group，在 <code>YAML</code> 中用空字符就可以，而 <code>Deployment</code> 属于 apps 这个 API Group， <code>ReplicaSets</code> 属于 <code>extensions</code> 这个 API Group，所以 rules 下面的 apiGroups 就综合了这几个资源的 API Group: <code>[&quot;&quot;, &quot;extensions&quot;, &quot;apps&quot;]</code>，其中 <code>verbs</code> 就是我们上面提到的可以对这些资源对象执行的操作，我们这里需要所有的操作方法，所以我们也可以使用 <code>[&quot;*&quot;]</code> 来代替。</p> <p>然后创建这个 <code>Role</code></p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ kubectl create -f qzy-role.yaml
role.rbac.authorization.k8s.io/qzy-role created
</code></pre></div><p>注意这里我们没有使用上面的 <code>qzy-context</code> 这个上下文了，因为木有权限啦</p> <h3 id="_3-创建角色权限绑定"><a href="#_3-创建角色权限绑定" aria-hidden="true" class="header-anchor">#</a> 3 创建角色权限绑定</h3> <p>Role 创建完成了，但是很明显现在我们这个 Role 和我们的用户 qzy 还没有任何关系, 这里我就需要创建一个 <code>RoleBinding</code> 对象，在 test 这个命名空间下面将上面的 qzy-role 角色和用户 qzy 进行绑定</p> <p><code>qzy-rolebinding.yaml</code></p> <div class="language-yaml extra-class"><pre class="language-yaml"><code><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> rbac.authorization.k8s.io/v1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> RoleBinding
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> qzy<span class="token punctuation">-</span>rolebinding
  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> test <span class="token comment"># 要绑定的命名空间</span>
<span class="token key atrule">subjects</span><span class="token punctuation">:</span> <span class="token comment"># 要绑定的用户</span>
<span class="token punctuation">-</span> <span class="token key atrule">kind</span><span class="token punctuation">:</span> User
  <span class="token key atrule">name</span><span class="token punctuation">:</span> qzy
  <span class="token key atrule">apiGroup</span><span class="token punctuation">:</span> <span class="token string">&quot;&quot;</span>
<span class="token key atrule">roleRef</span><span class="token punctuation">:</span> <span class="token comment"># 要绑定的角色</span>
  <span class="token key atrule">kind</span><span class="token punctuation">:</span> Role
  <span class="token key atrule">name</span><span class="token punctuation">:</span> qzy<span class="token punctuation">-</span>role
  <span class="token key atrule">apiGroup</span><span class="token punctuation">:</span> <span class="token string">&quot;&quot;</span>
</code></pre></div><p>上面的 <code>YAML</code> 文件中我们看到了 <code>subjects</code> 关键字，这里就是我们上面提到的用来尝试操作集群的对象，这里对应上面的 User 帐号 qzy，使用 <code>kubectl</code> 创建上面的资源对象：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ kubectl create -f qzy-rolebinding.yaml
rolebinding.rbac.authorization.k8s.io/qzy-rolebinding created
</code></pre></div><h3 id="_4-测试"><a href="#_4-测试" aria-hidden="true" class="header-anchor">#</a> 4 测试</h3> <p>现在我们应该可以上面的 <code>qzy-context</code> 上下文来操作集群了：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ kubectl get pods --context<span class="token operator">=</span>qzy-context <span class="token comment"># 允许访问 pods</span>
NAME                     READY   STATUS    RESTARTS   AGE
nginx-test-229g8         1/1     Running   2          4d21h
nginx-test-hdxfs         1/1     Running   0          4d21h
nginx-test-ls69t         1/1     Running   1          4d22h
test1-567899468c-5lfgd   1/1     Running   0          4d14h

$ kubectl get svc --context<span class="token operator">=</span>qzy-context <span class="token comment"># 禁止访问 service</span>
Error from server <span class="token punctuation">(</span>Forbidden<span class="token punctuation">)</span>: services is forbidden: User <span class="token string">&quot;qzy&quot;</span> cannot list resource <span class="token string">&quot;services&quot;</span> <span class="token keyword">in</span> API group <span class="token string">&quot;&quot;</span> <span class="token keyword">in</span> the namespace <span class="token string">&quot;test&quot;</span>
</code></pre></div><p>我们可以看到我们使用 <code>kubectl</code> 的使用并没有指定 namespace 了，这是因为我们已经为该用户分配了权限了，如果我们在后面加上一个 <code>-n default</code> 试看看呢？</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ kubectl --context<span class="token operator">=</span>qzy-context get pods --namespace<span class="token operator">=</span>default
Error from server <span class="token punctuation">(</span>Forbidden<span class="token punctuation">)</span>: pods is forbidden: User <span class="token string">&quot;haimaxy&quot;</span> cannot list pods <span class="token keyword">in</span> the namespace <span class="token string">&quot;default&quot;</span>
</code></pre></div><p>权限不足, 因为该用户并没有 default 这个命名空间的操作权限</p> <h2 id="创建一个只能访问某个-namespace-的-serviceaccount"><a href="#创建一个只能访问某个-namespace-的-serviceaccount" aria-hidden="true" class="header-anchor">#</a> 创建一个只能访问某个 namespace 的 ServiceAccount</h2> <p>上面我们创建了一个只能访问某个命名空间下面的普通用户，我们前面也提到过 subjects 下面还有一个类型的主题资源：ServiceAccount，现在我们来创建一个集群内部的用户只能操作 test 这个命名空间下面的 pods 和 deployments，首先来创建一个 ServiceAccount 对象：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ kubectl create sa qzy-sa -n <span class="token function">test</span>
</code></pre></div><p>当然我们也可以定义成 <code>YAML</code> 文件的形式来创建。</p> <p>然后新建一个 Role 对象：(qzy-sa-role.yaml)</p> <div class="language-yaml extra-class"><pre class="language-yaml"><code><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> rbac.authorization.k8s.io/v1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> Role
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> qzy<span class="token punctuation">-</span>sa<span class="token punctuation">-</span>role
  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> test
<span class="token key atrule">rules</span><span class="token punctuation">:</span>
<span class="token punctuation">-</span> <span class="token key atrule">apiGroups</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">&quot;&quot;</span><span class="token punctuation">]</span>
  <span class="token key atrule">resources</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">&quot;pods&quot;</span><span class="token punctuation">]</span>
  <span class="token key atrule">verbs</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">&quot;get&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;watch&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;list&quot;</span><span class="token punctuation">]</span>
<span class="token punctuation">-</span> <span class="token key atrule">apiGroups</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">&quot;apps&quot;</span><span class="token punctuation">]</span>
  <span class="token key atrule">resources</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">&quot;deployments&quot;</span><span class="token punctuation">]</span>
  <span class="token key atrule">verbs</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">&quot;get&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;list&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;watch&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;create&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;update&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;patch&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;delete&quot;</span><span class="token punctuation">]</span>
</code></pre></div><p>可以看到我们这里定义的角色没有创建、删除、更新 Pod 的权限，待会我们可以重点测试一下，创建该 Role 对象：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ kubectl create -f qzy-sa-role.yaml
</code></pre></div><p>然后创建一个 RoleBinding 对象，将上面的 qzy-sa 和角色 qzy-sa-role 进行绑定：(qzy-sa-rolebinding.yaml)</p> <div class="language-yaml extra-class"><pre class="language-yaml"><code><span class="token key atrule">kind</span><span class="token punctuation">:</span> RoleBinding
<span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> rbac.authorization.k8s.io/v1
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> qzy<span class="token punctuation">-</span>sa<span class="token punctuation">-</span>rolebinding
  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> test <span class="token comment"># 要绑定的命名空间</span>
<span class="token key atrule">subjects</span><span class="token punctuation">:</span> <span class="token comment"># 要绑定的 ServiceAccount</span>
<span class="token punctuation">-</span> <span class="token key atrule">kind</span><span class="token punctuation">:</span> ServiceAccount
  <span class="token key atrule">name</span><span class="token punctuation">:</span> qzy<span class="token punctuation">-</span>sa
  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> test
<span class="token key atrule">roleRef</span><span class="token punctuation">:</span> <span class="token comment"># 要绑定的角色</span>
  <span class="token key atrule">kind</span><span class="token punctuation">:</span> Role
  <span class="token key atrule">name</span><span class="token punctuation">:</span> qzy<span class="token punctuation">-</span>sa<span class="token punctuation">-</span>role
  <span class="token key atrule">apiGroup</span><span class="token punctuation">:</span> rbac.authorization.k8s.io
</code></pre></div><p>添加这个资源对象：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ kubectl create -f qzy-sa-rolebinding.yaml
</code></pre></div><p>然后我们怎么去验证这个 ServiceAccount 呢？我们前面的课程中是不是提到过一个 ServiceAccount 会生成一个 Secret 对象和它进行映射，这个 Secret 里面包含一个 token，我们可以利用这个 token 去登录 Dashboard，然后我们就可以在 Dashboard 中来验证我们的功能是否符合预期了：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ kubectl get secret -n <span class="token function">test</span> <span class="token operator">|</span> <span class="token function">grep</span> qzy-sa
qzy-sa-token-nxgqx                  kubernetes.io/service-account-token   3         47m

$ kubectl get secret qzy-sa-token-nxgqx -o jsonpath<span class="token operator">=</span><span class="token punctuation">{</span>.data.token<span class="token punctuation">}</span> -n <span class="token function">test</span> <span class="token operator">|</span> base64 -d
<span class="token comment"># 会生成一串很长的base64后的字符串</span>
</code></pre></div><p>使用这里的 token 去 Dashboard 页面进行登录：</p> <div class="imgLink" data-v-16222526><img src="https://img.xiaoyulive.top/img/date/20190422/003.png" data-v-16222526></div> <p>我们可以看到上面的提示信息，这是因为我们登录进来后默认跳转到 default 命名空间，我们切换到 kube-system 命名空间下面就可以了：</p> <div class="imgLink" data-v-16222526><img src="https://img.xiaoyulive.top/img/date/20190422/004.png" data-v-16222526></div> <p>我们可以看到可以访问pod列表了，但是也会有一些其他额外的提示：events is forbidden: User “system:serviceaccount:test:qzy-sa” cannot list events in the namespace &quot;test&quot;，这是因为当前登录用只被授权了访问 pod 和 deployment 的权限，同样的，访问下deployment看看可以了吗？</p> <p>同样的，你可以根据自己的需求来对访问用户的权限进行限制，可以自己通过 Role 定义更加细粒度的权限，也可以使用系统内置的一些权限……</p> <h2 id="创建一个可以访问所有-namespace-的-serviceaccount"><a href="#创建一个可以访问所有-namespace-的-serviceaccount" aria-hidden="true" class="header-anchor">#</a> 创建一个可以访问所有 namespace 的 ServiceAccount</h2> <p>刚刚我们创建的 <code>qzy-sa</code> 这个 ServiceAccount 和一个 Role 角色进行绑定的，如果我们现在创建一个新的 ServiceAccount，需要他操作的权限作用于所有的 namespace，这个时候我们就需要使用到 ClusterRole 和 ClusterRoleBinding 这两种资源对象了。同样，首先新建一个 ServiceAcount 对象：</p> <p><code>qzy-sa2.yaml</code></p> <div class="language-yaml extra-class"><pre class="language-yaml"><code><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> ServiceAccount
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> qzy<span class="token punctuation">-</span>sa2
  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> test
</code></pre></div><p>创建 ServiceAccount：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ kubectl create -f qzy-sa2.yaml
</code></pre></div><p>然后创建一个 ClusterRoleBinding 对象:</p> <p><code>qzy-clusterolebinding.yaml</code></p> <div class="language-yaml extra-class"><pre class="language-yaml"><code><span class="token key atrule">kind</span><span class="token punctuation">:</span> ClusterRoleBinding
<span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> rbac.authorization.k8s.io/v1beta1
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> qzy<span class="token punctuation">-</span>sa2<span class="token punctuation">-</span>clusterrolebinding
<span class="token key atrule">subjects</span><span class="token punctuation">:</span>
<span class="token punctuation">-</span> <span class="token key atrule">kind</span><span class="token punctuation">:</span> ServiceAccount
  <span class="token key atrule">name</span><span class="token punctuation">:</span> qzy<span class="token punctuation">-</span>sa2
  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> test
<span class="token key atrule">roleRef</span><span class="token punctuation">:</span>
  <span class="token key atrule">kind</span><span class="token punctuation">:</span> ClusterRole
  <span class="token key atrule">name</span><span class="token punctuation">:</span> cluster<span class="token punctuation">-</span>admin
  <span class="token key atrule">apiGroup</span><span class="token punctuation">:</span> rbac.authorization.k8s.io
</code></pre></div><p>从上面我们可以看到我们没有为这个资源对象声明 namespace，因为这是一个 ClusterRoleBinding 资源对象，是作用于整个集群的，我们也没有单独新建一个 ClusterRole 对象，而是使用的 cluster-admin 这个对象，这是 <code>Kubernetes</code> 集群内置的 ClusterRole 对象，我们可以使用 <code>kubectl get clusterrole</code> 和 <code>kubectl get clusterrolebinding</code> 查看系统内置的一些集群角色和集群角色绑定，这里我们使用的 cluster-admin 这个集群角色是拥有最高权限的集群角色，所以一般需要谨慎使用该集群角色。</p> <p>创建上面集群角色绑定资源对象，创建完成后同样使用 ServiceAccount 对应的 token 去登录 Dashboard 验证下：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ kubectl create -f qzy-clusterolebinding.yaml
$ kubectl get secret -n <span class="token function">test</span> <span class="token operator">|</span> <span class="token function">grep</span> qzy-sa2
qzy-sa2-token-nxgqx                  kubernetes.io/service-account-token   3         47m
$ kubectl get secret qzy-sa2-token-nxgqx -o jsonpath<span class="token operator">=</span><span class="token punctuation">{</span>.data.token<span class="token punctuation">}</span> -n <span class="token function">test</span> <span class="token operator">|</span> base64 -d
<span class="token comment"># 会生成一串很长的base64后的字符串</span>
</code></pre></div><p>我们在最开始接触到 <code>RBAC</code> 认证的时候，可能不太熟悉，特别是不知道应该怎么去编写 <code>rules</code> 规则，大家可以去分析系统自带的 clusterrole、clusterrolebinding 这些资源对象的编写方法，怎么分析？还是利用 kubectl 的 get、describe、 -o yaml 这些操作，所以 <code>kubectl</code> 最基本的用户一定要掌握好。</p> <h2 id="service-account"><a href="#service-account" aria-hidden="true" class="header-anchor">#</a> Service Account</h2> <p>Service Account (SA) 为 Pod 中的进程提供身份信息。</p> <p>当您（真人用户）访问集群（例如使用<code>kubectl</code>命令）时，apiserver 会将您认证为一个特定的 User Account（目前通常是<code>admin</code>，除非您的系统管理员自定义了集群配置）。Pod 容器中的进程也可以与 apiserver 联系。当它们在联系 apiserver 的时候，它们会被认证为一个特定的 Service Account（例如<code>default</code>）。</p> <h3 id="使用默认的-serviceaccount-访问-api-server"><a href="#使用默认的-serviceaccount-访问-api-server" aria-hidden="true" class="header-anchor">#</a> 使用默认的 ServiceAccount 访问 API server</h3> <p>当您创建 pod 的时候，如果您没有指定一个 service account，系统会自动地在与该 pod 相同的 namespace 下为其指派一个<code>default</code> service account。如果您获取刚创建的 pod 的原始 json 或 yaml 信息（例如使用<code>kubectl get pods/podename -o yaml</code>命令），您将看到<code>spec.serviceAccountName</code>字段已经被设置为 <code>default</code>。</p> <p>您可以在 pod 中使用自动挂载的 service account 凭证来访问 API，如 <a href="https://kubernetes.io/docs/user-guide/accessing-the-cluster/#accessing-the-api-from-a-pod" target="_blank" rel="noopener noreferrer">Accessing the Cluster<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 中所描述。</p> <p>Service account 是否能够取得访问 API 的许可取决于您使用的 <a href="https://kubernetes.io/docs/admin/authorization/#a-quick-note-on-service-accounts" target="_blank" rel="noopener noreferrer">授权插件和策略<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p> <p>在 1.6 以上版本中，您可以选择取消为 service account 自动挂载 API 凭证，只需在 service account 中设置 <code>automountServiceAccountToken: false</code>：</p> <div class="language-yaml extra-class"><pre class="language-yaml"><code><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> ServiceAccount
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> build<span class="token punctuation">-</span>robot
<span class="token key atrule">automountServiceAccountToken</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>
<span class="token punctuation">...</span>
</code></pre></div><p>在 1.6 以上版本中，您也可以选择只取消单个 pod 的 API 凭证自动挂载：</p> <div class="language-yaml extra-class"><pre class="language-yaml"><code><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> my<span class="token punctuation">-</span>pod
<span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">serviceAccountName</span><span class="token punctuation">:</span> build<span class="token punctuation">-</span>robot
  <span class="token key atrule">automountServiceAccountToken</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>
  <span class="token punctuation">...</span>
</code></pre></div><p>如果在 pod 和 service account 中同时设置了 <code>automountServiceAccountToken</code>, pod 设置中的优先级更高。</p> <h3 id="serviceaccount-的常用操作"><a href="#serviceaccount-的常用操作" aria-hidden="true" class="header-anchor">#</a> ServiceAccount 的常用操作</h3> <h4 id="创建-serviceaccount"><a href="#创建-serviceaccount" aria-hidden="true" class="header-anchor">#</a> 创建 ServiceAccount</h4> <p>通过命令方式创建 ServiceAccount:</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ kubectl create sa build-robot -n <span class="token function">test</span>
</code></pre></div><p>也可以像这样创建一个 ServiceAccount 对象：</p> <div class="language-yaml extra-class"><pre class="language-yaml"><code><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> ServiceAccount
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> build<span class="token punctuation">-</span>robot
  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> test
</code></pre></div><h4 id="获取-serviceaccount-信息"><a href="#获取-serviceaccount-信息" aria-hidden="true" class="header-anchor">#</a> 获取 ServiceAccount 信息</h4> <p>如果您看到如下的 ServiceAccount 对象的完整输出信息：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ kubectl get sa/build-robot -o yaml
apiVersion: v1
kind: Secret
metadata:
  name: build-robot-secret
  annotations:
    kubernetes.io/service-account.name: build-robot
type: kubernetes.io/service-account-token
</code></pre></div><p>查看 ServiceAccount 的详细信息, 包括 token:</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ kubectl describe secrets/build-robot-secret
Name:   build-robot-secret
Namespace:  default
Labels:   <span class="token operator">&lt;</span>none<span class="token operator">&gt;</span>
Annotations:  kubernetes.io/service-account.name<span class="token operator">=</span>build-robot,kubernetes.io/service-account.uid<span class="token operator">=</span>870ef2a5-35cf-11e5-8d06-005056b45392

Type: kubernetes.io/service-account-token

Data
<span class="token operator">==</span><span class="token operator">==</span>
ca.crt: 1220 bytes
token: <span class="token punctuation">..</span>.
namespace: 7 bytes
</code></pre></div><h4 id="删除-serviceaccount"><a href="#删除-serviceaccount" aria-hidden="true" class="header-anchor">#</a> 删除 ServiceAccount</h4> <div class="language-bash extra-class"><pre class="language-bash"><code>$ kubectl delete sa/build-robot -n <span class="token function">test</span>
</code></pre></div><h2 id="参考资料"><a href="#参考资料" aria-hidden="true" class="header-anchor">#</a> 参考资料</h2> <ul><li><a href="https://www.colabug.com/3271006.html" target="_blank" rel="noopener noreferrer">Kubernetes RBAC 详解<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://www.kubernetes.org.cn/service-account" target="_blank" rel="noopener noreferrer">名词解释：Service Account - Kubernetes 中文文档<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div><div class="article-info"><div class="article-title">文档信息</div><p class="article-item">版权声明：著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><p class="article-item">文章标题：Kubernetes 核心概念 - 角色的访问控制 (RBAC)</p><p class="article-item">原文链接：<a href="https://www.xiaoyulive.top/categories/cluster/kubernetes/_pages/RBAC.html">https://www.xiaoyulive.top/categories/cluster/kubernetes/_pages/RBAC.html</a></p><p class="article-item">发表日期：2019-04-22</p></div><!----><!----></div><div class="footers" data-v-38547c78><p data-v-38547c78><span data-v-38547c78>MIT Licensed | Copyright © 2018-present  滇ICP备16006294号</span></p><p data-v-38547c78><span data-v-38547c78>Design by <a href="/">Quanzaiyu</a> | Power by <a href="https://vuepress.vuejs.org/" target="_blank">VuePress</a> | Hosted by <a href="https://pages.coding.me" target="_blank" style="font-weight: bold">Coding Pages</a></span></p></div></div><div class="global-ui"><!----><!----></div></div>
    <script src="/assets/js/app.25c87086.js" defer></script><script src="/assets/js/5.314447d8.js" defer></script><script src="/assets/js/14.1aec49d6.js" defer></script>
  </body>
</html>
